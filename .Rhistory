Scaling 1 (distance biplot): Se prioriza que la distancia entre objetos en el gráfico respete tanto como sea posible las distancias euclidias de la matriz original. Los ángulos entre vectores (variables) pueden ser distorsionados.
Scaling 2 (correlation biplot): Se prioriza que los ángulos entre vectores respeten la correlación original entre variables. La distancia entre objetos en el gráfico puede estar distorsionada.
En resumen, utilizaremos scaling 1 si nos interesa más ver cómo se diferencian los objetos, y
scaling 2 si nos interesa más ver cómo se relacionan las distintas variables.
https://bookdown.org/stephi_gascon/bookdown-demo-master_-_multivariant/_book/ordination.html
https://fukamilab.github.io/BIO202/06-B-constrained-ordination.html
#### 10. Percentage explained by constrained and unconstrained variables.
Linear dependencies can be explored by computing the variables’ variance
inflation factors (VIF), which measure the proportion by which the variance of a
regression coefficient is inflated in the presence of other explanatory variables.
VIFs above 20 indicate strong collinearity. Ideally, VIFs above 10 should be at least
examined, and avoided if possible. VIFs can be computed in vegan after RDA
or CCA: (Bocard et al. page 175)
Linear dependencies can be explored by computing the variables’ variance
inflation factors (VIF), which measure the proportion by which the variance of a
regression coefficient is inflated in the presence of other explanatory variables.
VIFs above 20 indicate strong collinearity. Ideally, VIFs above 10 should be at least
examined, and avoided if possible. VIFs can be computed in vegan after RDA
or CCA: (Bocard et al. page 175)
Then, we can calculate Variance Inflation Factors (VIF) for each of the constraints (variables) from the environmental matrix. If we find an environmental variable with VIF>10, we'll know that this variable presents colinearity with another or other variables. In that case, we would have to delete the variable from our initial dataset and redo all the analysis. In our example, no variable is redundant with each other (all of them have VIF<10).
Linear dependencies can be explored by computing the variables’ variance
inflation factors (VIF), which measure the proportion by which the variance of a
regression coefficient is inflated in the presence of other explanatory variables.
VIFs above 20 indicate strong collinearity. Ideally, VIFs above 10 should be at least
examined, and avoided if possible. VIFs can be computed in vegan after RDA
or CCA (Bocard et al. page 175)
Then, we can calculate Variance Inflation Factors (VIF) for each of the constraints (variables) from the environmental matrix. If we find an environmental variable with VIF>10, we'll know that this variable presents colinearity with another or other variables. In that case, we would have to delete the variable from our initial dataset and redo all the analysis. In our example, no variable is redundant with each other (all of them have VIF<10).
Linear dependencies can be explored by computing the variables’ variance
inflation factors (VIF), which measure the proportion by which the variance of a
regression coefficient is inflated in the presence of other explanatory variables.
VIFs above 20 indicate strong collinearity. Ideally, VIFs above 10 should be at least
examined, and avoided if possible. VIFs can be computed in vegan after RDA
or CCA
Then, we can calculate Variance Inflation Factors (VIF) for each of the constraints (variables) from the environmental matrix. If we find an environmental variable with VIF>10, we'll know that this variable presents colinearity with another or other variables. In that case, we would have to delete the variable from our initial dataset and redo all the analysis. In our example, no variable is redundant with each other (all of them have VIF<10).
Linear dependencies can be explored by computing the variables’ variance
inflation factors (VIF), which measure the proportion by which the variance of a
regression coefficient is inflated in the presence of other explanatory variables.
VIFs above 20 indicate strong collinearity. Ideally, VIFs above 10 should be at least
examined, and avoided if possible. VIFs can be computed in vegan after RDA or CCA (Bocard et al. page 175)
Then, we can calculate Variance Inflation Factors (VIF) for each of the constraints (variables) from the environmental matrix. If we find an environmental variable with VIF>10, we'll know that this variable presents colinearity with another or other variables. In that case, we would have to delete the variable from our initial dataset and redo all the analysis. In our example, no variable is redundant with each other (all of them have VIF<10).
Linear dependencies can be explored by computing the variables’ variance inflation factors (VIF), which measure the proportion by which the variance of a regression coefficient is inflated in the presence of other explanatory variables.
VIFs above 20 indicate strong collinearity. Ideally, VIFs above 10 should be at least examined, and avoided if possible. VIFs can be computed in vegan after RDA or CCA (Bocard et al. page 175)
Then, we can calculate Variance Inflation Factors (VIF) for each of the constraints (variables) from the environmental matrix. If we find an environmental variable with VIF>10, we'll know that this variable presents colinearity with another or other variables. In that case, we would have to delete the variable from our initial dataset and redo all the analysis. In our example, no variable is redundant with each other (all of them have VIF<10).
Linear dependencies can be explored by computing the variables’ variance inflation factors (VIF), which measure the proportion by which the variance of a regression coefficient is inflated in the presence of other explanatory variables. VIFs above 20 indicate strong collinearity. Ideally, VIFs above 10 should be at least examined, and avoided if possible. VIFs can be computed in vegan after RDA or CCA (Bocard et al. page 175)
#### 8. Test for colinearity
Then, we can calculate Variance Inflation Factors (VIF) for each of the constraints (variables) from the environmental matrix. If we find an environmental variable with VIF>10, we'll know that this variable presents colinearity with another or other variables. In that case, we would have to delete the variable from our initial dataset and redo all the analysis. In our example, no variable is redundant with each other (all of them have VIF<10).
Linear dependencies can be explored by computing the variables’ variance inflation factors (VIF), which measure the proportion by which the variance of a regression coefficient is inflated in the presence of other explanatory variables. VIFs above 20 indicate strong collinearity. Ideally, VIFs above 10 should be at least examined, and avoided if possible. VIFs can be computed in vegan after RDA or CCA (Bocard et al. page 175)
#### 8. Test for colinearity
Then, we can calculate Variance Inflation Factors (VIF) for each of the constraints (variables) from the environmental matrix. If we find an environmental variable with VIF>10, we'll know that this variable presents colinearity with another or other variables. In that case, we would have to delete the variable from our initial dataset and redo all the analysis. In our example, no variable is redundant with each other (all of them have VIF<10). Linear dependencies can be explored by computing the variables’ variance inflation factors (VIF), which measure the proportion by which the variance of a regression coefficient is inflated in the presence of other explanatory variables. VIFs above 20 indicate strong collinearity. Ideally, VIFs above 10 should be at least examined, and avoided if possible. VIFs can be computed in vegan after RDA or CCA (Bocard et al. page 175)
step_forward <- ordistep(rda_Forward_Sel, scope=formula(rda_var),
direction = "forward", perm.max=200, pstep=999)
```
?ordistep
<br/>
rda_Forward_Sel <- rda(species.hel~ 1, data= env_1)
library(ggplot2)
library(dplyr)
library(vegan)
library(ggplot2)
library(dplyr)
library(vegan)
<br/>
#### **Step 2**
Data<br>
_Cargar los datos._
```{r}
species=read.csv("D:/Curriculum/07_ Cursos/Course_Multivariate_Stat_for_Ecological_Data/data/RDA_species.csv", header=T, row.names=NULL, sep=",")
env=read.csv("D:/Curriculum/07_ Cursos/Course_Multivariate_Stat_for_Ecological_Data/data/RDA_environmetal_standart.csv", header=T, row.names=NULL, sep=",")
```
<br/>
#### **Step 3**
_Remover la columna de sitos._
```{r}
species_1 <- select(species, -site)
env_1 <- select(env, -site)
```
<br/>
#### **Step 4**
**_Transformar datos._** _Hellinger es una transformaci&aacute;n recomendada por Legendre & Callagher (2001) en datos de abundancia y con una respuesta lineal._
```{r}
species.hel <- decostand(species_1, method = "hellinger")
```
<br/>
### **Seleccion de variables Forward**
_Muchas veces uno desea reducir el n&aacute;mero de variables explicatiivas de un modelo.  Para qu&eacute; hace esto? 1) Para buscar parsimonia (la soluci&oacute;n mas simple con menos variables) en el modelo; 2) Por sospechas de correlaci&oacute;n entre variables explicativas.  Esto &uacute;ltimo podr&iacute;a volver inestables los coeficientes de regresi&oacute;n de las variables explicativas del modelo (Borcard et al. 2012)._
```{r}
rda_Forward_Sel <- rda(species.hel~ 1, data= env_1)
rda_var <- rda(species.hel ~ temperature + oxygen + pH +
conductivity, data= env_1, scale=T)
# scope must give the formula of the largest possible model (maximum model)
step_forward <- ordiR2step(rda_Forward_Sel, scope=formula(rda_var),
direction = "forward", perm.max=200, pstep=999)
anova(step_forward)
laselva_full  <- read.csv("D:/Curriculum/07_ Cursos/Course_Multivariate_Stat_for_Ecological_Data/data/laSelva.csv")
stressplot(laselva.mds)
laselva_full  <- read.csv("D:/Curriculum/07_ Cursos/Course_Multivariate_Stat_for_Ecological_Data/data/Cluster_analysis_fish_PR.csv")
# Ward Hierarchical Clustering
d <- dist(species.fish, method = "euclidean") # distance matrix
species.fish  <- read.csv("D:/Curriculum/19_ Personal webpage/TropicalFreshwaterEcology/_pages/Lectures/data/Cluster_analysis_fish_PR.csv")
head(species.fish)
```{r}
# Ward Hierarchical Clustering
d <- dist(species.fish, method = "euclidean") # distance matrix
spe.fish  <- read.csv("D:/Curriculum/19_ Personal webpage/TropicalFreshwaterEcology/_pages/Lectures/data/Cluster_analysis_fish_PR.csv")
head(spe.fish)
species.fish <- dplyr::select(spe.fish, Amazon_Sailfin_Catfish:Tilapia)
# Ward Hierarchical Clustering
d <- dist(species.fish, method = "euclidean") # distance matrix
fit <- hclust(d, method="ward")
fit <- hclust(d, method="ward.D2")
plot(fit) # display dendogram
plot(fit, cex = 0.6, hang = -1) # display dendogram
spe.fish
spe.fish  <- read.csv("D:/Curriculum/19_ Personal webpage/TropicalFreshwaterEcology/_pages/Lectures/data/Cluster_analysis_fish_PR.csv")
head(spe.fish)
# Ward Hierarchical Clustering
d <- dist(spe.fish, method = "euclidean") # distance matrix
spe.fish  <- read.csv("D:/Curriculum/19_ Personal webpage/TropicalFreshwaterEcology/_pages/Lectures/data/Cluster_analysis_fish_PR.csv", row.names = 1)
spe.fish  <- read.csv("D:/Curriculum/19_ Personal webpage/TropicalFreshwaterEcology/_pages/Lectures/data/Cluster_analysis_fish_PR.csv", header = TRUE, row.names = 1)
spe.fish  <- read.csv("D:/Curriculum/19_ Personal webpage/TropicalFreshwaterEcology/_pages/Lectures/data/Cluster_analysis_fish_PR.csv", header = TRUE, row.names = F)
spe.fish  <- read.csv("D:/Curriculum/19_ Personal webpage/TropicalFreshwaterEcology/_pages/Lectures/data/Cluster_analysis_fish_PR.csv", header = TRUE, row.names = 1)
# Ward Hierarchical Clustering
d <- dist(spe.fish, method = "euclidean") # distance matrix
fit <- hclust(d, method="ward.D2")
plot(fit, cex = 0.6, hang = -1) # display dendogram
cut_avg <- cutree(fit, k = 3)
# Ward Hierarchical Clustering
d <- dist(spe.fish, method = "euclidean") # distance matrix
spe.fish  <- read.csv("D:/Curriculum/19_ Personal webpage/TropicalFreshwaterEcology/_pages/Lectures/data/Cluster_analysis_fish_PR.csv", header = TRUE, row.names = 1)
head(spe.fish)
# Ward Hierarchical Clustering
d <- dist(spe.fish, method = "euclidean") # distance matrix
fit <- hclust(d, method="ward.D2")
plot(fit, cex = 0.6, hang = -1) # display dendogram
# Ward Hierarchical Clustering
d <- dist(spe.fish, method = "euclidean") # distance matrix
fit <- hclust(d, method="ward.D2")
plot(fit, cex = 0.6, hang = -1) # display dendogram
```{r}
cut_avg <- cutree(fit, k = 3)
rect.hclust(fit, k = 3, border = 2:6)
# Ward Hierarchical Clustering
dist.fish <- dist(spe.fish, method = "euclidean") # distance matrix
fish_clust <- hclust(dist.fish, method="ward.D2")
plot(fish_clust, cex = 0.6, hang = -1) # display dendogram
rect.hclust(fish_clust, k = 3, border = 2:6)
abline(h = 3, col = 'red')
cut_avg
rect.hclust(fish_clust, k = 3, border = 2:6)
abline(h = 3, col = 'red')
cut_avg <- cutree(fish_clust, k = 3)
fish_clust
cut_avg <- cutree(fish_clust, k = 3)
cut_avg
cut_avg <- cutree(fish_clust, k = 100)
cut_avg <- cutree(fish_clust, k = 11)
cut_avg
table(cut_avg)
cut_avg
plot(fish_clust, cex = 0.6, hang = -1)
rect.hclust(fish_clust, k = 3, border = 2:6)
# abline(h = 100, col = 'red')
```
<br>
#### **Step 3: Cluster**
_Identificar a que grupo pertenece cada dato_
```{r}
cut_avg <- cutree(fish_clust, k = 3)
cut_avg
table(cut_avg)
View(spe.fish)
fviz_nbclust(spe.fish, FUN = hcut, method = "wss")
library(factoextra)
fviz_nbclust(spe.fish, FUN = hcut, method = "wss")
fviz_nbclust(spe.fish, FUN = hcut, method = "silhouette")
cut_avg <- cutree(fish_clust, k = 5)
cut_avg
plot(fish_clust, cex = 0.6, hang = -1)
rect.hclust(fish_clust, k = 5, border = 2:6)
fviz_nbclust(spe.fish, FUN = hcut, method = "wss")
fviz_nbclust(spe.fish, kmeans, method = "wss") +
geom_vline(xintercept = 4, linetype = 2) + # add line for better visualisation
labs(subtitle = "Elbow method") # add subtitle
```{r}
fviz_nbclust(spe.fish, kmeans, method = "wss") +
geom_vline(xintercept = 5, linetype = 2) + # add line for better visualisation
labs(subtitle = "Elbow method") # add subtitle
plot(fish_clust, cex = 0.6, hang = -1, ylab = "Eucludian distance")
plot(fish_clust, cex = 0.6, hang = -1,
main = "Cluster dendrogram", sub = NULL,
xlab = "", ylab = "Eucludian distance")
plot(fish_clust, cex = 0.6, hang = -1, labels = FALSE,
main = "Cluster dendrogram", sub = NULL,
xlab = "", ylab = "Eucludian distance")
NbClust(spe.fish, method = "ward.D2")
library(NbClust)
install.packages("NbClust")
library(NbClust)
NbClust(spe.fish, method = "ward.D2")
NbClust(spe.fish, k = max_nc, method = "ward.D2")
NbClust(spe.fish, k = 3, method = "ward.D2")
NbClust(spe.fish, method = "ward.D2")
?NbClust
NbClust(spe.fish, method = "ward.D2",min.nc = 2, max.nc = 11)
NbClust(spe.fish, method = "ward.D2",min.nc = 1, max.nc = 11)
NbClust(spe.fish, method = "ward.D2", max.nc = 3)
NbClust(spe.fish, diss=diss_matrix, distance = "NULL", min.nc=2, max.nc=6,
method = "ward", index = "all", alphaBeale = 0.1)
NbClust(spe.fish, diss=diss_matrix,  min.nc=2, max.nc=6,
method = "ward", index = "all", alphaBeale = 0.1)
NbClust(spe.fish, min.nc=2, max.nc=6,
method = "ward", index = "all", alphaBeale = 0.1)
NbClust(spe.fish, min.nc=2, max.nc=15, method="kmeans")
NbClust(spe.fish, min.nc=2, max.nc=15, method="ward.D2")
NbClust(spe.fish, min.nc=1, max.nc=11, method="ward.D2")
library(vegan)
library(factoextra)
spe.fish
dist.fish <- dist(spe.fish, method = "euclidean")
dist.fish
dist.fish <- dist(spe.fish, method = "euclidean")
dist.fish <- dist(spe.fish, method = "gower")
dist.fish <- dist(spe.fish, method = "bray")
?dist
dist.fish <- dist(spe.fish, method = "manhattan")
dist.fish
dist.fish <- dist(spe.fish, method = "euclidean")
dist.fish
fish_clust <- hclust(dist.fish, method = "ward.D2")
plot(fish_clust)
plot(fish_clust, cex = 0.6, hang = -1)
plot(fish_clust, cex = 0.6, hang = -1,
main = "Cluster dendrogram", sub = NULL,
xlab = "", ylab = "Euclidean distance")
dist.fish <- dist(spe.fish, method = "manhattan")
fish_clust <- hclust(dist.fish, method = "ward.D2")
plot(fish_clust, cex = 0.6, hang = -1,
main = "Cluster dendrogram", sub = NULL,
xlab = "", ylab = "Euclidean distance")
dist.fish <- dist(spe.fish, method = "minkowski")
fish_clust <- hclust(dist.fish, method = "ward.D2")
plot(fish_clust, cex = 0.6, hang = -1)
plot(fish_clust, cex = 0.6, hang = -1,
main = "Cluster dendrogram", sub = NULL,
xlab = "", ylab = "Euclidean distance")
rect.hclust(fish_clust, k=3)
rect.hclust(fish_clust, k=3,border = 2:6)
rect.hclust(fish_clust, k=3,border = 2:6)
cut_avg <- cutree(fish_clust, k = 3)
cut_avg
plot(fish_clust, cex = 0.6, hang = -1)
rect.hclust(fish_clust, k=5,border = 2:6)
fviz_nbclust(spe.fish, kmeans, method = "wss")
fviz_nbclust(spe.fish, kmeans, method = "wss") +
geom_vline(xintercept = 5, linetype = 2) + # add line for better visualisation
labs(subtitle = "Elbow method") # add subtitle
Elbow method
plot(fish_clust, cex = 0.6, hang = -1,
main = "Cluster dendrogram", sub = NULL,
xlab = "", ylab = "Euclidean distance")
rect.hclust(fish_clust, k=5,border = 2:6)
fviz_nbclust(spe.fish, kmeans, method = "silhouette") +
labs(subtitle = "Silhouette method")
?fviz_nbclust
spe.fish
library(ggplot2)
library(dplyr)
library(vegan)
species=read.csv("D:/Curriculum/07_ Cursos/Course_Multivariate_Stat_for_Ecological_Data/data/RDA_species.csv", header=T, row.names=NULL, sep=",")
env=read.csv("D:/Curriculum/07_ Cursos/Course_Multivariate_Stat_for_Ecological_Data/data/RDA_environmetal_standart.csv", header=T, row.names=NULL, sep=",")
View(env)
env=read.csv("D:/Curriculum/07_ Cursos/Course_Multivariate_Stat_for_Ecological_Data/data/RDA_environmetal_standart.csv", header=T, row.names=NULL, sep=",")
View(env)
```{r}
species=read.csv("D:/Curriculum/07_ Cursos/Course_Multivariate_Stat_for_Ecological_Data/data/RDA_species.csv", header=T, row.names=NULL, sep=",")
env=read.csv("D:/Curriculum/07_ Cursos/Course_Multivariate_Stat_for_Ecological_Data/data/RDA_environmetal_standart.csv", header=T, row.names=NULL, sep=",")
View(env)
species_1 <- select(species, -site)
env_1 <- select(env, -site)
species_1 <- select(species, -site)
env_1 <- select(env, -site)
<br/>
#### **Step 4**
**_Transformar datos._** _Hellinger es una transformaci&aacute;n recomendada por Legendre & Callagher (2001) en datos de abundancia y con una respuesta lineal._
```{r}
species.hel <- decostand(species_1, method = "hellinger")
```
<br/>
## **Variation partitioning by partial RDA**
**Variation partitioning** is a type of analysis that combines **simple RDA** and **partial RDA** to divide the variation of a response variable among two, three or four explanatory data sets. Variation partitioning are generally represented by Venn diagram in which the percentage of explained variance by each explanatory data set (or combination of data stets) is reported.<br>
_**La partici&oacute;n de la variaci&oacute;n** es un tipo de an&aacute;lisis que combina un **RDA simple** y un **RDA parcial** para dividir la variaci&oacute;n de una variable de respuesta entre dos, tres o cuatro conjuntos de datos explicativos. La partici&oacute;n de variaci&oacute;n generalmente se representa mediante un diagrama de Venn en el que se informa el porcentaje de varianza explicada por cada conjunto de datos explicativos (o combinaci&oacute;n de stets de datos)._
<br/>
#### **Step 1: Partition the Variation**
_Construir el modelo y ejecutar un RDA con las matrices (diferentes factores) separadas._
```{r}
varp <- varpart(species.hel, ~ temperature + oxygen + pH + conductivity,
~plants + land_use + margin, ~season, data = env_1)
varp
```
Legendre (2008) argued that "Negative values of Adj. R<sup>2</sup> are interpreted as zeros; they correspond to cases where the explanatory variables explain less variation than random normal variables would."<br>
_Legendre (2008) sugiere que "**los valores negativos de Adj. R<sup>2</sup> se interpretan como ceros**". Estos valores corresponden a casos donde las variables explicativas explican menos variaci&oacute;n que las variables normales aleatorias"_
<br/>
#### **Step 2: Partition the Variation**
Plot the results. The plot shows the adjusted R<sup>2</sup> values associated with each partition or for overlapping partitions.<br>
_Graficar los resultados. El gr&aacute;fico muestra los valores de R<sup>2</sup> ajustados asociados con cada partici&oacute;n o para particiones superpuestas._
```{r}
plot(varp, digits = 2, Xnames = c('Enviromental factors', 'Vegetation', "Season"),
bg = c('navy', 'tomato', "lightblue"))
```{r}
varp <- varpart(species.hel, ~ temperature + oxygen + pH + conductivity,
~plants + land_use + margin, ~season,
~richness + abundance + shannon, data = env_1)
varp
varp <- varpart(species.hel, ~ temperature + oxygen + pH + conductivity,
~plants + land_use + margin, ~season,
~richness + abundance + shannon, data = env_1)
varp
#### **Step 1: Partition the Variation**
_Construir el modelo y ejecutar un RDA con las matrices (diferentes factores) separadas._
```{r}
varp <- varpart(species.hel, ~ temperature + oxygen + pH + conductivity,
~plants + land_use + margin, ~season,
~richness + abundance + shannon, data = env_1)
varp
```
Legendre (2008) argued that "Negative values of Adj. R<sup>2</sup> are interpreted as zeros; they correspond to cases where the explanatory variables explain less variation than random normal variables would."<br>
_Legendre (2008) sugiere que "**los valores negativos de Adj. R<sup>2</sup> se interpretan como ceros**". Estos valores corresponden a casos donde las variables explicativas explican menos variaci&oacute;n que las variables normales aleatorias"_
<br/>
#### **Step 2: Partition the Variation**
Plot the results. The plot shows the adjusted R<sup>2</sup> values associated with each partition or for overlapping partitions.<br>
_Graficar los resultados. El gr&aacute;fico muestra los valores de R<sup>2</sup> ajustados asociados con cada partici&oacute;n o para particiones superpuestas._
```{r}
plot(varp, digits = 2, Xnames = c('Enviromental factors', 'Vegetation', "Season"),
bg = c('navy', 'tomato', "lightblue"))
```{r}
plot(varp, digits = 2, Xnames = c('Enviromental factors', 'Vegetation',
"Season","Macroinvertebrates"),
bg = c('navy', 'tomato', "lightblue","gold"))
```{r}
varp <- varpart(species.hel, ~ temperature + oxygen + pH + conductivity,
~plants + land_use + margin, ~season,
shannon, data = env_1)
varp
```{r}
varp <- varpart(species.hel, ~ temperature + oxygen + pH + conductivity,
~plants + land_use + margin, ~season,
~shannon, data = env_1)
varp
```{r}
varp <- varpart(species.hel, ~ temperature + oxygen + pH + conductivity,
~ plants + land_use + margin, ~season,
~ shannon, data = env_1)
varp
plot(varp, digits = 2, Xnames = c('Enviromental factors', 'Vegetation',
"Season","Macroinvertebrates"),
bg = c('navy', 'tomato', "lightblue","gold"))
# significance of partition from Environment (physicochemical variables)
anova(rda(species.hel ~ temperature + oxygen + pH + conductivity +
Condition(plants + land_use + margin) +
Condition(season) + Condition(shannon), data=env_1))
# Significance of partition from Physical characteristics
anova(rda(species.hel ~ plants + land_use + margin +
Condition(temperature + oxygen + pH + conductivity) +
Condition(season),+ Condition(shannon), data=env_1))
# Significance of partition from Physical characteristics
anova(rda(species.hel ~ plants + land_use + margin +
Condition(temperature + oxygen + pH + conductivity) +
Condition(season) + Condition(shannon), data=env_1))
# Significance of partition from Season
anova(rda(species.hel ~ season +
Condition(plants + land_use + margin) +
Condition(temperature + oxygen + pH + conductivity)
+ Condition(shannon), data=env_1))
anova(rda(species.hel ~ shannon +
Condition(plants + land_use + margin) +
Condition(temperature + oxygen + pH + conductivity)
+ Condition(season), data=env_1))
library(ggplot2)
library(dplyr)
library(vegan)
library(ggplot2)
library(dplyr)
library(vegan)
<br/>
#### **Step 2**
Data<br>
_Cargar los datos._
```{r}
species=read.csv("D:/Curriculum/07_ Cursos/Course_Multivariate_Stat_for_Ecological_Data/data/RDA_species.csv", header=T, row.names=NULL, sep=",")
env=read.csv("D:/Curriculum/07_ Cursos/Course_Multivariate_Stat_for_Ecological_Data/data/RDA_environmetal_standart.csv", header=T, row.names=NULL, sep=",")
```
<br/>
#### **Step 3**
_Remover la columna de sitos._
```{r}
species_1 <- select(species, -site)
env_1 <- select(env, -site)
```
<br/>
#### **Step 4**
**_Transformar datos._** _Hellinger es una transformaci&aacute;n recomendada por Legendre & Callagher (2001) en datos de abundancia y con una respuesta lineal._
```{r}
species.hel <- decostand(species_1, method = "hellinger")
```
<br/>
## **Variation partitioning by partial RDA**
**Variation partitioning** is a type of analysis that combines **simple RDA** and **partial RDA** to divide the variation of a response variable among two, three or four explanatory data sets. Variation partitioning are generally represented by Venn diagram in which the percentage of explained variance by each explanatory data set (or combination of data stets) is reported.<br>
_**La partici&oacute;n de la variaci&oacute;n** es un tipo de an&aacute;lisis que combina un **RDA simple** y un **RDA parcial** para dividir la variaci&oacute;n de una variable de respuesta entre dos, tres o cuatro conjuntos de datos explicativos. La partici&oacute;n de variaci&oacute;n generalmente se representa mediante un diagrama de Venn en el que se informa el porcentaje de varianza explicada por cada conjunto de datos explicativos (o combinaci&oacute;n de stets de datos)._
<br/>
#### **Step 1: Partition the Variation**
_Construir el modelo y ejecutar un RDA con las matrices (diferentes factores) separadas._
```{r}
varp <- varpart(species.hel, ~ temperature + oxygen + pH + conductivity,
~ plants + land_use + margin, ~season,
~ shannon, data = env_1)
varp
```
Legendre (2008) argued that "Negative values of Adj. R<sup>2</sup> are interpreted as zeros; they correspond to cases where the explanatory variables explain less variation than random normal variables would."<br>
_Legendre (2008) sugiere que "**los valores negativos de Adj. R<sup>2</sup> se interpretan como ceros**". Estos valores corresponden a casos donde las variables explicativas explican menos variaci&oacute;n que las variables normales aleatorias"_
```{r}
species=read.csv("D:/Curriculum/07_ Cursos/Course_Multivariate_Stat_for_Ecological_Data/data/RDA_species.csv", header=T, row.names=NULL, sep=",")
env=read.csv("D:/Curriculum/07_ Cursos/Course_Multivariate_Stat_for_Ecological_Data/data/RDA_environmetal_standart.csv", header=T, row.names=NULL, sep=",")
species=read.csv("D:/Curriculum/07_ Cursos/Course_Multivariate_Stat_for_Ecological_Data/data/RDA_species.csv", header=T, row.names=NULL, sep=",")
env=read.csv("D:/Curriculum/07_ Cursos/Course_Multivariate_Stat_for_Ecological_Data/data/RDA_environmetal_standart.csv", header=T, row.names=NULL, sep=",")
<br/>
#### **Step 3**
_Remover la columna de sitos._
```{r}
species_1 <- select(species, -site)
env_1 <- select(env, -site)
```
<br/>
env_1 <- select(env, -site)
species.hel <- decostand(species_1, method = "hellinger")
varp <- varpart(species.hel, ~ temperature + oxygen + pH + conductivity,
~ plants + land_use + margin, ~season,
~ shannon, data = env_1)
View(env)
species=read.csv("D:/Curriculum/07_ Cursos/Course_Multivariate_Stat_for_Ecological_Data/data/RDA_species.csv", header=T, row.names=NULL, sep=",")
env=read.csv("D:/Curriculum/07_ Cursos/Course_Multivariate_Stat_for_Ecological_Data/data/RDA_environmetal_standart.csv", header=T, row.names=NULL, sep=",")
species=read.csv("D:/Curriculum/07_ Cursos/Course_Multivariate_Stat_for_Ecological_Data/data/RDA_species.csv", header=T, row.names=NULL, sep=",")
env=read.csv("D:/Curriculum/07_ Cursos/Course_Multivariate_Stat_for_Ecological_Data/data/RDA_environmetal_standart.csv", header=T, row.names=NULL, sep=",")
<br/>
#### **Step 3**
_Remover la columna de sitos._
```{r}
species_1 <- select(species, -site)
env_1 <- select(env, -site)
```
<br/>
#### **Step 4**
**_Transformar datos._** _Hellinger es una transformaci&aacute;n recomendada por Legendre & Callagher (2001) en datos de abundancia y con una respuesta lineal._
```{r}
species.hel <- decostand(species_1, method = "hellinger")
```
<br/>
## **Variation partitioning by partial RDA**
**Variation partitioning** is a type of analysis that combines **simple RDA** and **partial RDA** to divide the variation of a response variable among two, three or four explanatory data sets. Variation partitioning are generally represented by Venn diagram in which the percentage of explained variance by each explanatory data set (or combination of data stets) is reported.<br>
_**La partici&oacute;n de la variaci&oacute;n** es un tipo de an&aacute;lisis que combina un **RDA simple** y un **RDA parcial** para dividir la variaci&oacute;n de una variable de respuesta entre dos, tres o cuatro conjuntos de datos explicativos. La partici&oacute;n de variaci&oacute;n generalmente se representa mediante un diagrama de Venn en el que se informa el porcentaje de varianza explicada por cada conjunto de datos explicativos (o combinaci&oacute;n de stets de datos)._
<br/>
#### **Step 1: Partition the Variation**
_Construir el modelo y ejecutar un RDA con las matrices (diferentes factores) separadas._
```{r}
varp <- varpart(species.hel, ~ temperature + oxygen + pH + conductivity,
~ plants + land_use + margin, ~season,
~ shannon, data = env_1)
varp
```
Legendre (2008) argued that "Negative values of Adj. R<sup>2</sup> are interpreted as zeros; they correspond to cases where the explanatory variables explain less variation than random normal variables would."<br>
_Legendre (2008) sugiere que "**los valores negativos de Adj. R<sup>2</sup> se interpretan como ceros**". Estos valores corresponden a casos donde las variables explicativas explican menos variaci&oacute;n que las variables normales aleatorias"_
varp
varp <- varpart(species.hel, ~ temperature + oxygen + pH + conductivity,
~ plants + land_use + margin, ~season,
~ shannon, data = env_1)
env=read.csv("D:/Curriculum/07_ Cursos/Course_Multivariate_Stat_for_Ecological_Data/data/RDA_environmetal_standart.csv", header=T, row.names=NULL, sep=",")
species=read.csv("D:/Curriculum/07_ Cursos/Course_Multivariate_Stat_for_Ecological_Data/data/RDA_species.csv", header=T, row.names=NULL, sep=",")
env=read.csv("D:/Curriculum/07_ Cursos/Course_Multivariate_Stat_for_Ecological_Data/data/RDA_environmetal_standart.csv", header=T, row.names=NULL, sep=",")
<br/>
#### **Step 3**
_Remover la columna de sitos._
```{r}
species_1 <- select(species, -site)
env_1 <- select(env, -site)
```
<br/>
#### **Step 4**
**_Transformar datos._** _Hellinger es una transformaci&aacute;n recomendada por Legendre & Callagher (2001) en datos de abundancia y con una respuesta lineal._
```{r}
species.hel <- decostand(species_1, method = "hellinger")
```
<br/>
## **Variation partitioning by partial RDA**
**Variation partitioning** is a type of analysis that combines **simple RDA** and **partial RDA** to divide the variation of a response variable among two, three or four explanatory data sets. Variation partitioning are generally represented by Venn diagram in which the percentage of explained variance by each explanatory data set (or combination of data stets) is reported.<br>
_**La partici&oacute;n de la variaci&oacute;n** es un tipo de an&aacute;lisis que combina un **RDA simple** y un **RDA parcial** para dividir la variaci&oacute;n de una variable de respuesta entre dos, tres o cuatro conjuntos de datos explicativos. La partici&oacute;n de variaci&oacute;n generalmente se representa mediante un diagrama de Venn en el que se informa el porcentaje de varianza explicada por cada conjunto de datos explicativos (o combinaci&oacute;n de stets de datos)._
<br/>
#### **Step 1: Partition the Variation**
_Construir el modelo y ejecutar un RDA con las matrices (diferentes factores) separadas._
```{r}
varp <- varpart(species.hel, ~ temperature + oxygen + pH + conductivity,
~ plants + land_use + margin, ~season,
~ shannon, data = env_1)
varp
```
Legendre (2008) argued that "Negative values of Adj. R<sup>2</sup> are interpreted as zeros; they correspond to cases where the explanatory variables explain less variation than random normal variables would."<br>
_Legendre (2008) sugiere que "**los valores negativos de Adj. R<sup>2</sup> se interpretan como ceros**". Estos valores corresponden a casos donde las variables explicativas explican menos variaci&oacute;n que las variables normales aleatorias"_
varp <- varpart(species.hel, ~ temperature + oxygen + pH + conductivity,
~ plants + land_use + margin, ~season,
~ shannon, data = env_1)
varp
plot(varp, digits = 2, Xnames = c('Enviromental factors', 'Vegetation',
"Season","Macroinvertebrates"),
bg = c('navy', 'tomato', "lightblue","gold"))
